# Busy Beaver
A software Turing Machine implementation with the necessary groundwork for creating busy beaver programs as C++ classes. Includes example busy beaver implementations, based on the 2-state, 2-symbol and 4-state, 2-symbol programs described in [the Wikipedia article](https://en.wikipedia.org/wiki/Busy_beaver#Examples) (see `FourStateBusyBeaver` and `TwoStateBusyBeaver`).

To create and run your own busy beaver program, create and instantiate a subclass of `BusyBeaverProgram` with an `instructionsTable` `std::map` (following the example of the classes mentioned above), or even just simply construct an object of the base `BusyBeaverProgram` with your instructions table as an argument. Then pass the busy beaver object to a Turing Machine instance and `run()`.

# Implementation Details
What follows are more involved details on how the pieces of the busy beaver runner fit together.

As noted above, a busy beaver program starts when a `BusyBeaverProgram` instance is passed to the `TuringMachine`'s `run()` function. The Turing Machine then continuously calls back the program's own `execute()`, passing itself in as an argument, until the `HALT` state is reached. A busy beaver program does three primary things: writes a symbol to the tape, moves the head, and sets the new machine state (this description assumes the reader knows the basics of Turing Machines. If not, see [the Wikipedia page](https://en.wikipedia.org/wiki/Turing_machine)). The information necessary to perform all three tasks is contained in an `Instruction` object. Each call to the busy beaver's `execute()` will have a different `Instruction` (though the same instruction might be executed more than once in the course of running a busy beaver program). Which `Instruction` should be executed is decided by two factors: the current `State` of the Turing Machine, and which symbol (for these purposes, '0' or '1') is written to the tape cell currently under the head of the machine. The instructions for each combination of symbol and state are stored in the busy beaver's `instructionsTable`. An instruction table is a `std::map` composed of `std::array`s of `Instruction`s. Each entry in the map corresponds to a Turing Machine `State` (i.e. the keys are instances of `State`). The program instructs the machine to get its current `State` so that it can retrieve the `Instruction`s that apply to that `State`. With the correct `std::array` of `Instruction`s, the machine can then retrieve the index of the `array` that matches the symbol under the head. Once the `Instruction` is retrieved, the three tasks outlined above can be performed. This process continues until the machine reaches the `HALT` state (though of course it might never halt, and [we can't say for sure whether it will or not for any given program](https://en.wikipedia.org/wiki/Halting_problem)), at which point it outputs the contents of the tape and exits.
